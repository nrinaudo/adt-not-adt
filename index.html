<!Doctype html>
<html>
    <head>
        <title>When is an ADT not an ADT?</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <link rel="stylesheet" type="text/css" href="css/style.css"/>
    </head>
    <body>
        <textarea id="source">
class: center, middle

# When is an ADT not an ADT?

[Nicolas Rinaudo] • [@NicolasRinaudo@functional.cafe]

---

class: center, middle

# Abstract Data types

---

## Addition

.center[![](img/1_plus_2.svg)]

```scala
1 + 2
```

???

The simplest expression we want to support: addition.

---

## Addition

.center[![](img/exp_1_plus_2.svg)]

```scala
class Add(lhs: Int, rhs: Int)

```

---

## Addition

.center[![](img/exp_1_plus_2.svg)]

```scala
Add(1, 2)
```

---

## Addition

.center[![](img/1_plus_2_plus_3.svg)]

```scala
1 + 2 + 3
```

???

We want to be able to chain additions, so we'll need `Add` to take expressions.

---

## Addition

.center[![](img/1_add_2_add_3.svg)]

```scala
Add(
  1,
  Add(2, 3)
)
```

---

## Addition

.center[![](img/exp_1_plus_2_plus_3.svg)].center[![](img/1_add_2_add_3.svg)]

```scala
class Num(value: Int)
class Add(lhs: Num, rhs: Num)

```

---

## Addition

.center[![](img/exp_1_plus_2_plus_3.svg)]

```scala
abstract class Exp

class Num(value: Int) extends Exp
class Add(lhs: Exp, rhs: Exp) extends Exp

```

---

## Addition

.center[![](img/exp_1_plus_2_plus_3.svg)]

```scala
Add(
  Num(1),
  Add(Num(2), Num(3))
)
```

---

## Equality

.center[![](img/1_eq_2.svg)]

```scala
1 = 2
```

???

Another thing we want to express is the notion of equality. For that, we need the equal operator.

---

## Equality

.center[![](img/exp_1_eq_2.svg)]

```scala
class Eq(lhs: Exp, rhs: Exp) extends Exp

```

---

## Pretty printing

.center[![](img/1_plus_2_eq_2_plus_1.svg)]

```scala
1 + 2 = 2 + 1
```

???
Now that we know how to do all this, we would like to be able to print things for human readers.
The default behaviour is pretty dire.

---

## Pretty printing

.center[![](img/exp_1_plus_2_eq_2_plus_1.svg)]

```scala
Eq(
  Add(Num(1), Num(2)),
  Add(Num(2), Num(1))
).toString
// val res2: String = Eq@2a9e754e
```

---

## Pretty printing

```scala
abstract class Exp:
  def toString: String

```

???

Interpreters, in an Abstract Data Type context, are abstract methods.

---

## Pretty printing

```scala
class Num(value: Int) extends Exp:
  override def toString = value.toString

class Add(lhs: Exp, rhs: Exp) extends Exp:
  override def toString = s"($lhs + $rhs)"

class Eq(lhs: Exp, rhs: Exp) extends Exp:
  override def toString = s"($lhs = $rhs)"

```

---

## Pretty printing

.center[![](img/exp_1_plus_2_eq_2_plus_1.svg)]

```scala
Eq(
  Add(Num(1), Num(2)),
  Add(Num(2), Num(1))
).toString
// val res3: String = ((1 + 2) = (2 + 1))
```

---

## Type checking

.center[![](img/exp_1_eq_2_plus_2_plus_1.svg)]

```scala
Add(
  Eq(Num(1), Num(2)),
  Add(Num(2), Num(1))
).toString
// val res4: String = ((1 = 2) + (2 + 1))
```

???
Unfortunately, this is considered valid, even though it makes no sense.

---

## Type checking

```scala
abstract class Exp[T]:
  def toString: String

```

???

This is solved by adding a type parameter that represents an `Exp`'s normal form.

---

## Type checking

```scala
class Num(value: Int) extends Exp[Int]:
  override def toString = value.toString

class Add(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]:
  override def toString = s"($lhs + $rhs)"

class Eq(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Boolean]:
  override def toString = s"($lhs = $rhs)"

```

---

## Type checking

.center[![](img/exp_1_eq_2_plus_2_plus_1.svg)]

```scala
Add(
  Eq(Num(1), Num(2)),
  Add(Num(2), Num(1))
).toString
// ⛔ Found:    Exp[Boolean]
//   Required: Exp[Int]
```

---

## Key takeaways

Feature              || Abstract Data Types
---------------------||--------------------
 Terms               || &nbsp;
 Interpreters        || &nbsp;
 Illegal states      || &nbsp;

---

## Key takeaways

Feature              || Abstract Data Types
---------------------||--------------------
 Terms               || classes
 Interpreters        || &nbsp;
 Illegal states      || &nbsp;

---

## Key takeaways

Feature              || Abstract Data Types
---------------------||--------------------
 Terms               || classes
 Interpreters        || methods
 Illegal states      || &nbsp;

---

## Key takeaways

Feature              || Abstract Data Types
---------------------||--------------------
 Terms               || classes
 Interpreters        || methods
 Illegal states      || impossible

---

class: center, middle

# Growing the language

---

## Adding terms: substraction

.center[![](img/2_minus_1.svg)]

```scala
2 - 1
```

???

We now want to see how complicated it is to add new terms to our language

---

## Adding terms: substraction

.center[![](img/exp_2_minus_1.svg)]

```scala
class Sub(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]:
  override def toString = s"($lhs - $rhs)"

```

---

## Adding terms: substraction

.center[![](img/3_minus_2_plus_1.svg)]

```scala
3 - (2 + 1)
```

???
Interestingly, this works very easily: we can immediately integrate it with the rest of the existing language with no further work.

---

## Adding terms: substraction

.center[![](img/exp_3_minus_2_plus_1.svg)]

```scala
Sub(
  Num(3),
  Add(Num(2), Num(1))
).toString
// val res5: String = (3 - (2 + 1))
```

---

## Adding interpreters: evaluation

.center[![](img/1_plus_2_eq_3_minus_1.svg)]

```scala
1 + 2 = 3 - 1
```

???

How about interpreters?

---

## Adding interpreters: evaluation

.center[![](img/exp_1_plus_2_eq_3_minus_1.svg)]

```scala
Eq(
  Add(Num(1), Num(2)),
  Sub(Num(3), Num(1))
)
```

---

## Adding interpreters: evaluation

```scala
abstract class Exp[T]:
  def toString: String
  def eval: T

```

---

## Adding interpreters: evaluation

```scala
class Num(value: Int) extends Exp[Int]:
  override def toString = value.toString
  override def eval     = value

class Add(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]:
  override def toString = s"($lhs + $rhs)"
  override def eval     = lhs.eval + rhs.eval

class Sub(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]:
  override def toString = s"($lhs - $rhs)"
  override def eval     = lhs.eval - rhs.eval

class Eq(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Boolean]:
  override def toString = s"($lhs = $rhs)"
  override def eval     = lhs.eval == rhs.eval

```

???

We have to modify every single implementation, including ones that we didn't write ourselves...

What if we want to add interpreters to types we did not write?

---

## Adding interpreters: evaluation

.center[![](img/exp_1_plus_2_eq_3_minus_1.svg)]

```scala
Eq(
  Add(Num(1), Num(2)),
  Sub(Num(3), Num(1))
).eval
// val res7: Boolean = false
```

---

## Key takeaways

Feature              || Abstract Data Types
---------------------||--------------------
 Term                || class
 Interpreter         || method
 Illegal states      || impossible
 Adding terms        || &nbsp;
 Adding interpreters || &nbsp;

---

## Key takeaways

Feature              || Abstract Data Types
---------------------||--------------------
 Term                || class
 Interpreter         || method
 Illegal states      || impossible
 Adding terms        || easy
 Adding interpreters || &nbsp;


---

## Key takeaways

Feature              || Abstract Data Types
---------------------||--------------------
 Term                || class
 Interpreter         || method
 Illegal states      || impossible
 Adding terms        || easy
 Adding interpreters || hard

---

class: center, middle

# Algebraic Data Types

---

## "Dumb" data

```scala
abstract class Exp[T]

class Num(val value: Int) extends Exp[Int]
class Add(val lhs: Exp[Int], val rhs: Exp[Int]) extends Exp[Int]
class Sub(val lhs: Exp[Int], val rhs: Exp[Int]) extends Exp[Int]
class Eq(val lhs: Exp[Int], val rhs: Exp[Int]) extends Exp[Boolean]

```

START FROM OOP EXP, REFACTOR

???

`Exp` is now a dumb data type with no logic.

We now need to write our interpreters as functions.

---

## Pretty printing

```scala
def print[T](exp: Exp[T]): String = exp match
  case i: Num => i.value.toString
  case a: Add => s"(${print(a.lhs)} + ${print(a.rhs)})"
  case m: Sub => s"(${print(m.lhs)} - ${print(m.rhs)})"
  case e: Eq  => s"(${print(e.lhs)} = ${print(e.rhs)})"

```

???

This is ok, but there's quite a bit of syntactic noise here.
Some languages, including Scala, have syntactic sugar.

---

## Product types

```scala
abstract class Exp[T]

case class Num(value: Int) extends Exp[Int]
case class Add(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
case class Sub(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
case class Eq(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Boolean]

```

---

## Product types

```scala
def print[T](exp: Exp[T]): String = exp match
  case Num(i)        => i.toString
  case Add(lhs, rhs) => s"(${print(lhs)} + ${print(rhs)})"
  case Sub(lhs, rhs) => s"(${print(lhs)} - ${print(rhs)})"
  case Eq(lhs, rhs)  => s"(${print(lhs)} = ${print(rhs)})"

```

---

## Exhaustivity

```scala
def eval[T](exp: Exp[T]): T = exp match
  case Num(i)        => i
  case Add(lhs, rhs) => eval(lhs) + eval(rhs)
  case Sub(lhs, rhs) => eval(lhs) - eval(rhs)

```

???

Note how I purposefully did not handle the `Eq` case.

---

## Exhaustivity

```scala
eval(Eq(
  Num(1),
  Num(2)
))
// scala.MatchError: Eq(Num(1),Num(2)) (of class repl$.rs$line$3$Eq)
//   at <console>.eval(<console>:4)
//   ... 36 elided
```

???

This is accepted by the compiler and triggers runtime errors, which we do not like.

---

## Exhaustivity

```scala
sealed abstract class Exp[T]

case class Num(value: Int) extends Exp[Int]
case class Add(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
case class Sub(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
case class Eq(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Boolean]

```

???

This can be fixed by giving guarantees to the compiler that it knows all possible implementations.

---

## Exhaustivity

```scala
def eval[T](exp: Exp[T]): T = exp match
  case Num(i)        => i
  case Add(lhs, rhs) => eval(lhs) + eval(rhs)
  case Sub(lhs, rhs) => eval(lhs) - eval(rhs)
// def eval[T](exp: Exp[T]): T = exp match
//                               ^
// ⛔ match may not be exhaustive.
//   
//   It would fail on pattern case: Eq(_, _)
// 1 error found
```

???

This now fails to compile!

---

## ADTs

```scala
enum Exp[T]:
  case Num(value: Int) extends Exp[Int]
  case Add(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
  case Sub(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
  case Eq(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Boolean]

```

???

Scala has syntax for this exact, enums, which are really sums of products.
It's a subset of Algebraic Data Types.

---

## Key takeaways

Feature              || Abstract Data Types | Algebraic Data Types
---------------------||---------------------|---------------------
 Term                || class               | &nbsp;
 Interpreter         || method              | &nbsp;
 Illegal states      || impossible          | &nbsp;
 Adding terms        || easy                | &nbsp;
 Adding interpreters || hard                | &nbsp;

---

## Key takeaways

Feature              || Abstract Data Types | Algebraic Data Types
---------------------||---------------------|---------------------
 Term                || class               | data type
 Interpreter         || method              | &nbsp;
 Illegal states      || impossible          | &nbsp;
 Adding terms        || easy                | &nbsp;
 Adding interpreters || hard                | &nbsp;

---

## Key takeaways

Feature              || Abstract Data Types | Algebraic Data Types
---------------------||---------------------|---------------------
 Term                || class               | data type
 Interpreter         || method              | function
 Illegal states      || impossible          | &nbsp;
 Adding terms        || easy                | &nbsp;
 Adding interpreters || hard                | &nbsp;


---

## Key takeaways


Feature              || Abstract Data Types | Algebraic Data Types
---------------------||---------------------|---------------------
 Term                || class               | data type
 Interpreter         || method              | function
 Illegal states      || impossible          | impossible
 Adding terms        || easy                | &nbsp;
 Adding interpreters || hard                | &nbsp;

---

class: center, middle

# Growing the language, again

---

## Adding terms: multiplication

.center[![](img/2_times_3.svg)]

```scala
2 * 3
```

---

## Adding terms: multiplication

```scala
enum Exp[T]:
  case Num(value: Int) extends Exp[Int]
  case Add(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
  case Sub(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
  case Mult(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Int]
  case Eq(lhs: Exp[Int], rhs: Exp[Int]) extends Exp[Boolean]

```

---

## Adding terms: multiplication

```scala
def print[T](exp: Exp[T]): String = exp match
  case Num(i)         => i.toString
  case Add(lhs, rhs)  => s"(${print(lhs)} + ${print(rhs)})"
  case Sub(lhs, rhs)  => s"(${print(lhs)} - ${print(rhs)})"
  case Eq(lhs, rhs)   => s"(${print(lhs)} = ${print(rhs)})"
// def print[T](exp: Exp[T]): String = exp match
//                                     ^
// ⛔ match may not be exhaustive.
//   
//   It would fail on pattern case: Exp.Mult(_, _)
// 1 error found
```

---

## Adding terms: multiplication

```scala
def print[T](exp: Exp[T]): String = exp match
  case Num(i)         => i.toString
  case Add(lhs, rhs)  => s"(${print(lhs)} + ${print(rhs)})"
  case Sub(lhs, rhs)  => s"(${print(lhs)} - ${print(rhs)})"
  case Mult(lhs, rhs) => s"(${print(lhs)} * ${print(rhs)})"
  case Eq(lhs, rhs)   => s"(${print(lhs)} = ${print(rhs)})"

```

---

## Adding terms: multiplication

```scala
def eval[T](exp: Exp[T]): T = exp match
  case Num(i)         => i
  case Add(lhs, rhs)  => eval(lhs) + eval(rhs)
  case Sub(lhs, rhs)  => eval(lhs) - eval(rhs)
  case Mult(lhs, rhs) => eval(lhs) * eval(rhs)
  case Eq(lhs, rhs)   => eval(lhs) == eval(rhs)

```

---

## Adding terms: multiplication

.center[![](img/exp_2_times_3.svg)]

```scala
print(Mult(
  Num(2),
  Num(3)
))
// val res1: String = (2 * 3)
```

---

## Adding terms: multiplication

.center[![](img/exp_2_times_3.svg)]

```scala
eval(Mult(
  Num(2),
  Num(3)
))
// val res2: Int = 6
```

---

## Adding interpreters: rewriting

.center[![](img/3_minus_neg_1.svg)]

```scala
3 - (-1)
```


---

## Adding interpreters: rewriting

.center[![](img/exp_3_minus_neg_1.svg)]

```scala
print(Sub(
  Num(3),
  Num(-1)
))
// val res3: String = (3 - -1)
```

---

## Adding interpreters: rewriting

```scala
def opt[T](exp: Exp[T]): Exp[T] = exp match
  case num: Num         => num
  case Add(lhs, rhs)    => Add(opt(lhs), opt(rhs))
  case Mult(lhs, rhs)   => Mult(opt(lhs), opt(rhs))
  case Eq(lhs, rhs)     => Eq(opt(lhs), opt(rhs))
  case Sub(lhs, Num(i)) => if i < 0 then Add(opt(lhs), Num(-i))
                           else          Sub(opt(lhs), Num(i))
  case Sub(lhs, rhs)    => Sub(opt(lhs), opt(rhs))

```

---

## Adding interpreters: rewriting

.center[![](img/exp_3_minus_neg_1.svg)]

```scala
print(Sub(
  Num(3),
  Num(-1)
))
// val res4: String = (3 - -1)
```

---

## Adding interpreters: rewriting

.center[![](img/exp_3_plus_1.svg)]

```scala
print(opt(Sub(
  Num(3),
  Num(-1)
)))
// val res5: String = (3 + 1)
```

---

## Key takeaways

Feature              || Abstract Data Types | Algebraic Data Types
---------------------||---------------------|---------------------
 Term                || class               | data type
 Interpreter         || method              | function
 Illegal states      || impossible          | impossible
 Adding terms        || easy                | &nbsp;
 Adding interpreters || hard                | &nbsp;


---

## Key takeaways

Feature              || Abstract Data Types | Algebraic Data Types
---------------------||---------------------|---------------------
 Term                || class               | data type
 Interpreter         || method              | function
 Illegal states      || impossible          | impossible
 Adding terms        || easy                | hard
 Adding interpreters || hard                | &nbsp;


---

## Key takeaways

Feature              || Abstract Data Types | Algebraic Data Types
---------------------||---------------------|---------------------
 Term                || class               | data type
 Interpreter         || method              | function
 Illegal states      || impossible          | impossible
 Adding terms        || easy                | hard
 Adding interpreters || hard                | easy

---
class: center, middle
name: questions

[<img src="img/qr-code.svg" width="50%" height="50%"/>][Slides]

[Nicolas Rinaudo] • [@NicolasRinaudo@functional.cafe]
[@NicolasRinaudo@functional.cafe]:https://functional.cafe/@NicolasRinaudo
[Nicolas Rinaudo]:https://nrinaudo.github.io/
[Slides]:https://nrinaudo.github.io/adt-not-adt/
    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
          highlightStyle: 'github',
          highlightSpans: true,
          highlightLines: true
      });
    </script>
  </body>
</html>
